"use strict";exports.id=967,exports.ids=[967],exports.modules={8967:(e,t,r)=>{r.r(t),r.d(t,{default:()=>u});const o=(e,t,r,o)=>{if("length"===r||"prototype"===r)return;if("arguments"===r||"caller"===r)return;const i=Object.getOwnPropertyDescriptor(e,r),a=Object.getOwnPropertyDescriptor(t,r);!n(i,a)&&o||Object.defineProperty(e,r,a)},n=function(e,t){return void 0===e||e.configurable||e.writable===t.writable&&e.enumerable===t.enumerable&&e.configurable===t.configurable&&(e.writable||e.value===t.value)},i=(e,t)=>`/* Wrapped ${e}*/\n${t}`,a=Object.getOwnPropertyDescriptor(Function.prototype,"toString"),c=Object.getOwnPropertyDescriptor(Function.prototype.toString,"name");const u=(e,t={})=>{if("function"!=typeof e)throw new TypeError(`Expected the first argument to be a function, got \`${typeof e}\``);const{wait:r=0,maxWait:n=Number.POSITIVE_INFINITY,before:u=!1,after:l=!0}=t;if(r<0||n<0)throw new RangeError("`wait` and `maxWait` must not be negative.");if(!u&&!l)throw new Error("Both `before` and `after` are false, function wouldn't be called.");let f,p,b;const s=function(...t){const o=this,i=u&&!f;return clearTimeout(f),f=setTimeout((()=>{f=void 0,p&&(clearTimeout(p),p=void 0),l&&(b=e.apply(o,t))}),r),n>0&&n!==Number.POSITIVE_INFINITY&&!p&&(p=setTimeout((()=>{p=void 0,f&&(clearTimeout(f),f=void 0),l&&(b=e.apply(o,t))}),n)),i&&(b=e.apply(o,t)),b};return function(e,t,{ignoreNonConfigurable:r=!1}={}){const{name:n}=e;for(const n of Reflect.ownKeys(t))o(e,t,n,r);((e,t)=>{const r=Object.getPrototypeOf(t);r!==Object.getPrototypeOf(e)&&Object.setPrototypeOf(e,r)})(e,t),((e,t,r)=>{const o=""===r?"":`with ${r.trim()}() `,n=i.bind(null,o,t.toString());Object.defineProperty(n,"name",c);const{writable:u,enumerable:l,configurable:f}=a;Object.defineProperty(e,"toString",{value:n,writable:u,enumerable:l,configurable:f})})(e,t,n)}(s,e),s.cancel=()=>{f&&(clearTimeout(f),f=void 0),p&&(clearTimeout(p),p=void 0)},s}}};