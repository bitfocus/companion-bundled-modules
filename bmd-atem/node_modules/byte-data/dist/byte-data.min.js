function endianness(t,r,e=0,n=t.length){if(n%r)throw Error("Bad buffer length.");for(let s=e;s<n;s+=r)swap(t,r,s)}function swap(t,r,e){r--;for(let n=0;n<r;n++){let s=t[e+n];t[e+n]=t[e+r],t[e+r]=s,r--}}function unpack(t,r=0,e=t.length){let n="";for(let s=r;s<e;){let r=128,e=191,i=!1,a=t[s++];if(a>=0&&a<=127)n+=String.fromCharCode(a);else{let o=0;a>=194&&a<=223?o=1:a>=224&&a<=239?(o=2,224===t[s]&&(r=160),237===t[s]&&(e=159)):a>=240&&a<=244?(o=3,240===t[s]&&(r=144),244===t[s]&&(e=143)):i=!0,a&=(1<<8-o-1)-1;for(let n=0;n<o;n++)(t[s]<r||t[s]>e)&&(i=!0),a=a<<6|63&t[s],s++;n+=i?"ï¿½":a<=65535?String.fromCharCode(a):String.fromCharCode(55296+((a-=65536)>>10&1023),56320+(1023&a))}}return n}function pack(t,r,e=0){for(let n=0,s=t.length;n<s;n++){let s=t.codePointAt(n);if(s<128)r[e]=s,e++;else{let t=0,i=0;for(s<=2047?(t=1,i=192):s<=65535?(t=2,i=224):s<=1114111&&(t=3,i=240,n++),r[e]=(s>>6*t)+i,e++;t>0;)r[e]=128|s>>6*(t-1)&63,e++,t--}}return e}const TYPE_ERR="Unsupported type",TYPE_NAN="Argument is not a valid number";function validateIsNumber(t){if(null==t)throw Error(TYPE_NAN);if(t.constructor!==Number&&t.constructor!==Boolean)throw Error(TYPE_NAN)}function validateFloatType(t){if(!t||16!==t&&32!==t&&64!==t)throw Error(TYPE_ERR+": float, bits: "+t)}function validateIntType(t){if(!t||t<1||t>53)throw Error(TYPE_ERR+": int, bits: "+t)}class IEEE754Buffer{constructor(t,r){this.ebits=t,this.fbits=r,this.bias=(1<<t-1)-1,this.numBytes=Math.ceil((t+r)/8),this.biasP2=Math.pow(2,this.bias+1),this.ebitsFbits=t+r,this.fbias=Math.pow(2,-(8*this.numBytes-1-t))}pack(t,r,e){Math.abs(r)>this.biasP2-2*this.ebitsFbits&&(r=r<0?-1/0:1/0);let n=((r=+r)||1/r)<0?1:r<0?1:0,s=Math.min(Math.floor(Math.log(r=Math.abs(r))/Math.LN2),1023),i=this.roundToEven(r/Math.pow(2,s)*Math.pow(2,this.fbits));return r!=r?(i=Math.pow(2,this.fbits-1),s=(1<<this.ebits)-1):0!==r&&(r>=Math.pow(2,1-this.bias)?(i/Math.pow(2,this.fbits)>=2&&(s+=1,i=1),s>this.bias?(s=(1<<this.ebits)-1,i=0):(s+=this.bias,i=this.roundToEven(i)-Math.pow(2,this.fbits))):(i=this.roundToEven(r/Math.pow(2,1-this.bias-this.fbits)),s=0)),this.packFloatBits_(t,e,n,s,i)}unpack(t,r){let e,n=(1<<this.ebits)-1,s="";for(let e=this.numBytes-1;e>=0;e--){let n=t[e+r].toString(2);s+="00000000".substring(n.length)+n}let i="1"==s.charAt(0)?-1:1;s=s.substring(1);let a=parseInt(s.substring(0,this.ebits),2);return s=s.substring(this.ebits),a==n?0!==parseInt(s,2)?NaN:i*(1/0):(0===a?(a+=1,e=parseInt(s,2)):e=parseInt("1"+s,2),i*e*this.fbias*Math.pow(2,a-this.bias))}packFloatBits_(t,r,e,n,s){let i=[];i.push(e);for(let t=this.ebits;t>0;t-=1)i[t]=n%2?1:0,n=Math.floor(n/2);let a=i.length;for(let t=this.fbits;t>0;t-=1)i[a+t]=s%2?1:0,s=Math.floor(s/2);let o=i.join(""),h=this.numBytes+r-1,u=r;for(;h>=r;)t[h]=parseInt(o.substring(0,8),2),o=o.substring(8),h--,u++;return u}roundToEven(t){var r=Math.floor(t),e=t-r;return e<.5?r:e>.5?r+1:r%2?r+1:r}}class UintBuffer{constructor(t){this.bits=t,this.bytes=t<8?1:Math.ceil(t/8),this.max=Math.pow(2,t)-1,this.min=0;let r=8-(1+(t-1|7)-t);this.lastByteMask_=Math.pow(2,r>0?r:8)-1}pack(t,r,e=0){if(r!=r)throw Error("NaN");this.overflow(r),t[e]=255&(r<0?r+Math.pow(2,this.bits):r),e++;let n=this.bytes;for(let s=2;s<n;s++)t[e]=255&Math.floor(r/Math.pow(2,8*(s-1))),e++;return this.bits>8&&(t[e]=Math.floor(r/Math.pow(2,8*(this.bytes-1)))&this.lastByteMask_,e++),e}unpack(t,r=0){let e=this.unpackUnsafe(t,r);return this.overflow(e),e}unpackUnsafe(t,r){let e=0;for(let n=0;n<this.bytes;n++)e+=t[r+n]*Math.pow(256,n);return e}overflow(t){if(t>this.max||t<this.min)throw Error("Overflow")}}class TwosComplementBuffer extends UintBuffer{constructor(t){super(t),this.max=Math.pow(2,this.bits)/2-1,this.min=-this.max-1}pack(t,r,e=0){return super.pack(t,r,e)}unpack(t,r=0){let e=super.unpackUnsafe(t,r);return e=this.sign_(e),this.overflow(e),e}sign_(t){return t>this.max&&(t-=2*this.max+2),t}}class NumberBuffer{constructor(t,r,e){let n;r?(validateFloatType(t),n=this.getFPParser_(t)):(validateIntType(t),n=e?new TwosComplementBuffer(t):new UintBuffer(t)),this.parser=n,this.offset=Math.ceil(t/8)}unpack(t,r=0){return this.parser.unpack(t,r)}pack(t,r,e=0){return this.parser.pack(t,r,e)}getFPParser_(t){return 16===t?new IEEE754Buffer(5,11):32===t?new IEEE754Buffer(8,23):new IEEE754Buffer(11,52)}}function throwValueError_(t,r,e,n){throw Error(n||r!==1/0&&r!==-1/0&&r==r?t.message+" at input index "+e+": "+r:"Argument is not a integer at input index "+e)}function getUnpackLen_(t,r,e,n,s){let i=(e-r)%n;if(s&&(i||t.length<n))throw Error("Bad buffer length");return e-i}function unpackString(t,r=0,e=t.length){return unpack(t,r,e)}function packString(t){let r=[];return pack(t,r,0),r}function packStringTo(t,r,e=0){return pack(t,r,e)}function packArrayTo(t,r,e,n=0){let s=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),i=0,a=n;try{for(let r=t.length;i<r;i++)validateIsNumber(t[i]),n=s.pack(e,t[i],n);r.be&&endianness(e,s.offset,a,n)}catch(e){throwValueError_(e,t[i],i,r.fp)}return n}function unpackArrayTo(t,r,e,n=0,s=t.length,i=!1){let a=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),o=a.offset;s=getUnpackLen_(t,n,s,o,i);let h=0,u=n;try{for(r.be&&endianness(t,o,n,s);u<s;u+=o,h++)e[h]=a.unpack(t,u);r.be&&endianness(t,o,n,s)}catch(e){throwValueError_(e,t.slice(u,u+o),u,r.fp)}}function packTo(t,r,e,n=0){return packArrayTo([t],r,e,n)}function pack$1(t,r){let e=[];return packTo(t,r,e),e}function packArray(t,r){let e=[];return packArrayTo(t,r,e),e}function unpackArray(t,r,e=0,n=t.length,s=!1){let i=[];return unpackArrayTo(t,r,i,e,n,s),i}function unpack$1(t,r,e=0){return unpackArray(t,r,e,e+Math.ceil(r.bits/8),!0)[0]}export{unpackString,packString,packStringTo,packArrayTo,unpackArrayTo,packTo,pack$1 as pack,packArray,unpackArray,unpack$1 as unpack};
