/// <reference types="node" />
import { IDeserializedCommand, ISerializableCommand } from '../commands/CommandBase';
import { DataTransfer, ProgressTransferResult, DataTransferState } from './dataTransfer';
import { VideoModeInfo } from '../lib/videoMode';
export interface UploadBufferInfo {
    /**
     * Encoded data in ATEM native format (eg YUVA for pixels, 24bit audio)
     */
    encodedData: Buffer;
    /**
     * Length of the encoded data, before any RLE encoding
     */
    rawDataLength: number;
    /**
     * Whether RLE encoding has been performed on this buffer (when supported)
     */
    isRleEncoded: boolean;
    /**
     * Hash for the encoded data, intended as a unique identifier/checksum
     * When `null`, one will be generated from the `encodedData`
     * This is returned by the ATEM when describing what is in each slot
     */
    hash: string | null;
}
export declare function generateHashForBuffer(data: Buffer): string;
export declare function generateUploadBufferInfo(data: Buffer | UploadBufferInfo, resolution: VideoModeInfo, shouldEncodeRLE: boolean): UploadBufferInfo;
export declare abstract class DataTransferUploadBuffer extends DataTransfer<void> {
    #private;
    protected readonly hash: string;
    protected readonly data: Buffer;
    constructor(buffer: UploadBufferInfo);
    protected abstract generateDescriptionCommand(transferId: number): ISerializableCommand;
    handleCommand(command: IDeserializedCommand, oldState: DataTransferState): Promise<ProgressTransferResult>;
    private getNextChunks;
}
//# sourceMappingURL=dataTransferUploadBuffer.d.ts.map