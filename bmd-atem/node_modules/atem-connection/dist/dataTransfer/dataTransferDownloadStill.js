"use strict";
var _DataTransferDownloadStill_data;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTransferDownloadStill = void 0;
const tslib_1 = require("tslib");
const DataTransfer_1 = require("../commands/DataTransfer");
const dataTransfer_1 = require("./dataTransfer");
// TODO - this should be reimplemented on top of a generic DataTransferDownloadBuffer class
class DataTransferDownloadStill extends dataTransfer_1.DataTransfer {
    constructor(poolIndex, stillIndex) {
        super();
        this.poolIndex = poolIndex;
        this.stillIndex = stillIndex;
        _DataTransferDownloadStill_data.set(this, []);
    }
    async startTransfer(transferId) {
        const command = new DataTransfer_1.DataTransferDownloadRequestCommand({
            transferId: transferId,
            transferStoreId: this.poolIndex,
            transferIndex: this.stillIndex,
            transferType: 0x00f9,
        });
        return {
            newState: dataTransfer_1.DataTransferState.Ready,
            commands: [command],
        };
    }
    async handleCommand(command, oldState) {
        if (command instanceof DataTransfer_1.DataTransferErrorCommand) {
            switch (command.properties.errorCode) {
                case DataTransfer_1.ErrorCode.Retry:
                    return this.restartTransfer(command.properties.transferId);
                case DataTransfer_1.ErrorCode.NotFound:
                    this.abort(new Error('Invalid download'));
                    return {
                        newState: dataTransfer_1.DataTransferState.Finished,
                        commands: [],
                    };
                default:
                    // Abort the transfer.
                    this.abort(new Error(`Unknown error ${command.properties.errorCode}`));
                    return {
                        newState: dataTransfer_1.DataTransferState.Finished,
                        commands: [],
                    };
            }
        }
        else if (command instanceof DataTransfer_1.DataTransferDataCommand) {
            tslib_1.__classPrivateFieldGet(this, _DataTransferDownloadStill_data, "f").push(command.properties.body);
            // todo - have we received all data? maybe check if the command.body < max_len
            return {
                newState: oldState,
                commands: [
                    new DataTransfer_1.DataTransferAckCommand({
                        transferId: command.properties.transferId,
                        transferIndex: this.stillIndex,
                    }),
                ],
            };
        }
        else if (command instanceof DataTransfer_1.DataTransferCompleteCommand) {
            this.resolvePromise(Buffer.concat(tslib_1.__classPrivateFieldGet(this, _DataTransferDownloadStill_data, "f")));
            return {
                newState: dataTransfer_1.DataTransferState.Finished,
                commands: [],
            };
        }
        return { newState: oldState, commands: [] };
    }
}
exports.DataTransferDownloadStill = DataTransferDownloadStill;
_DataTransferDownloadStill_data = new WeakMap();
//# sourceMappingURL=dataTransferDownloadStill.js.map